<?php

namespace Repositories;

use Doctrine\ORM\EntityRepository;

/**
 * CustomerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class Customer extends EntityRepository
{
    /**
     * DQL for selecting customers that are current in terms of `datejoin` and `dateleave`
     *
     * @var string DQL for selecting customers that are current in terms of `datejoin` and `dateleave`
     */
    const DQL_CUST_CURRENT = "c.datejoin <= CURRENT_DATE() AND ( c.dateleave IS NULL OR c.dateleave = '0000-00-00' OR c.dateleave >= CURRENT_DATE() )";
    
    /**
     * DQL for selecting customers that are active (i.e. not suspended)
     *
     * @var string DQL for selecting customers that are active (i.e. not suspended)
     */
    const DQL_CUST_ACTIVE = "c.status IN ( 1, 2 )";
    
    /**
     * DQL for selecting all customers except for internal / dummy customers
     *
     * @var string DQL for selecting all customers except for internal / dummy customers
     */
    const DQL_CUST_EXTERNAL = "c.type != 3";
    
    /**
     * DQL for selecting all trafficing customers
     *
     * @var string DQL for selecting all trafficing customers
     */
    const DQL_CUST_TRAFFICING = "c.type != 2";
    
    
    /**
     * Utility function to provide a count of different customer types as `type => count`
     * where type is as defined in Entities\Customer::$CUST_TYPES_TEXT
     *
     * @return array Number of customers of each customer type as `[type] => count`
     */
    public function getTypeCounts()
    {
        $atypes = $this->getEntityManager()->createQuery(
            "SELECT c.type AS ctype, COUNT( c.type ) AS cnt FROM Entities\\Customer c
                WHERE " . self::DQL_CUST_CURRENT . " AND " . self::DQL_CUST_ACTIVE . "
                GROUP BY c.type"
        )->getArrayResult();
        
        $types = [];
        foreach( $atypes as $t )
            $types[ $t['ctype'] ] = $t['cnt'];
    
        return $types;
    }
    
    
    /**
     * Utility function to provide a array of all active and current customers.
     *
     * @param bool $asArray If `true`, return an associative array, else an array of Customer objects
     * @param bool $trafficing If `true`, only include trafficing customers (i.e. no associates)
     * @param bool $externalOnly If `true`, only include external customers (i.e. no internal types)
     * @return array
     */
    public function getCurrentActive( $asArray = false, $trafficing = false, $externalOnly = false )
    {
        $dql = "SELECT c FROM \\Entities\\Customer c
                WHERE " . self::DQL_CUST_CURRENT . " AND " . self::DQL_CUST_ACTIVE;

        if( $trafficing )
            $dql .= " AND " . self::DQL_CUST_TRAFFICING;
        
        if( $externalOnly )
            $dql .= " AND " . self::DQL_CUST_EXTERNAL;
            
        $dql .= " ORDER BY c.name ASC";
        
        $custs = $this->getEntityManager()->createQuery( $dql );
        
        return $asArray ? $custs->getArrayResult() : $custs->getResult();
    }
    
    
    /**
     * Return an array of all customer names where the array key is the customer id.
     *
     * @return array An array of all customer names with the customer id as the key.
     */
    public function getNames()
    {
        $acusts = $this->getEntityManager()->createQuery(
            "SELECT c.id AS id, c.name AS name FROM Entities\\Customer c"
        )->getResult();
        
        $customers = [];
        foreach( $acusts as $c )
            $customers[ $c['id'] ] = $c['name'];
        
        return $customers;
    }
    
    /**
     * Return an array of the must recent customers (who are current,
     * external, active and trafficing).
     *
     * @param $limit int The number of customers to get
     * @return array An array of all customer names with the customer id as the key.
     */
    public function getRecent( $limit = 3 )
    {
        return $this->getEntityManager()->createQuery(
                "SELECT c
                 FROM \\Entities\\Customer c
                 WHERE " . self::DQL_CUST_CURRENT . " AND " . self::DQL_CUST_ACTIVE . "
                     AND " . self::DQL_CUST_EXTERNAL . " AND " . self::DQL_CUST_TRAFFICING . "
                ORDER BY c.datejoin DESC"
            )
            ->setMaxResults( $limit )
            ->useResultCache( true, 3600 )
            ->getResult();
    }
    
    
    /**
     * Utility function to load all customers suitable for inclusion in the peering manager
     *
     */
    public static function getForPeeringManager()
    {
        $q = Doctrine_Query::create()
        ->select( 'c.shortname, c.autsys, c.name, c.maxprefixes, c.peeringemail, c.peeringpolicy, c.id' )
        ->addSelect( 'vi.id, vli.ipv4enabled, vli.ipv6enabled, vli.rsclient, v.number' )
        ->from( 'Cust c' )
        ->leftJoin( 'c.Virtualinterface vi' )
        ->leftJoin( 'vi.Vlaninterface vli' )
        ->leftJoin( 'vli.Vlan v' )
        //->andWhere( 'c.activepeeringmatrix = 1' );
        ->andWhereIn( 'c.type', array( Cust::TYPE_FULL, Cust::TYPE_PROBONO ) )
        ->andWhere( '( c.dateleave IS NULL or c.dateleave = "0000-00-00" )' )
        ->orderBy( 'c.name' );
    
        $acusts = $q->execute( null, Doctrine::HYDRATE_ARRAY );
    
        $custs = array();
    
        foreach( $acusts as $c )
        {
            $custs[ $c['autsys'] ] = array();
    
            $custs[ $c['autsys'] ]['id']            = $c['id'];
            $custs[ $c['autsys'] ]['name']          = $c['name'];
            $custs[ $c['autsys'] ]['shortname']     = $c['shortname'];
            $custs[ $c['autsys'] ]['autsys']        = $c['autsys'];
            $custs[ $c['autsys'] ]['maxprefixes']   = $c['maxprefixes'];
            $custs[ $c['autsys'] ]['peeringemail']  = $c['peeringemail'];
            $custs[ $c['autsys'] ]['peeringpolicy'] = $c['peeringpolicy'];
    
            $custs[ $c['autsys'] ]['vlaninterfaces'] = array();
    
            foreach( $c['Virtualinterface'] as $vi )
            {
                foreach( $vi['Vlaninterface'] as $vli )
                {
                    if( !isset( $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ] ) )
                    {
                        $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ] = array();
                        $cnt = 0;
                    }
                    else
                        $cnt = count( $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ] );
                        
                    $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ][ $cnt ]['ipv4enabled'] = $vli['ipv4enabled'];
                    $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ][ $cnt ]['ipv6enabled'] = $vli['ipv6enabled'];
                    $custs[ $c['autsys'] ]['vlaninterfaces'][ $vli['Vlan']['number'] ][ $cnt ]['rsclient']    = $vli['rsclient'];
                }
            }
                         
        }
                        
        return $custs;
    }
                        
    
}
